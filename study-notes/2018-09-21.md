# 회의록
### 민정
- 8.1장까지 읽음, 관계형 데이터를 어떻게 저장하는지, join하는지 알게됐다.
- Object, nested, parent/child로 하는 3가지가 있다
- join이 nosql에 없는데, 이걸 하기위해서 denormalize, application에서 처리하는 것이 있다
- object타입은 말그대로 json 타입, 하나의 doc에 저장이 되어서 filter가 잘 안되는 단점이 있다
- 그래서 object 타입은 잘 안쓰일 것 같다, query를 제대로 하려면 못 쓸것 같다
- nested타입을 써야할 것 같다 그림 8.1, 그림8.2의 group, event 예시를 보고 이해할 수 있었다
- nested의 단점은 nested가 되어있는 doc을 하나 인덱싱할때, root doc + 기존 nested doc들도 모두 같이 인덱싱해야 한다는 단점이 있다
- Parent/child는 간단히 개요정도로 이해했다 자세히는 더 봐야할 것 같다
- denormalize는 nosql db에서 join할때 주로 사용한다고 이해했다 데이터를 중복시키는 것
- app에서의 join, group과 event 도큐먼트에 각각의 id만 들고있고, 각 도큐먼트에 쿼리를 하고, 쿼리된 도큐먼트에 있는 id 값으로 한번 더 쿼리를 해서 join을 하는 것

### 우현
- 관계에 대한 내용이라, admin서비스에 적용할 것을 생각하면서 읽었다
- object타입이 1:1관계에 좋을 것이라고 적혀있다.
- 중첩타입은 하나의 도큐먼트에 저장되어 있는데, 루씬에 색인될때만 다르게 들고있다
- parent/child 완전히 각각의 도큐먼트를 가지고 있는 것이라고 이해했다
- Nested(중첩)에서는 include_in_root으로하면, nested 형태에서도, object타입에서 검색하는 것처럼 사용할 수 있다
- nested타입은 es에서 하나의 도큐먼트로 되어있기때문에, 수정/삭제 할때마다 재색인을 해야해서, 성능상의 불이익이 있지만
반면에 Parent/child는 각자의 도큐먼트를 가지고있어서 상대적으로 불이익이 적다
- 답변(성우) 제 생각은 nested타입은 write할때 성능이 떨어지지만, 붙어있기 때문에 read할때는 오히려 더 이익
Parent/child는 각자 도큐먼트를 갖고있어서, write에 대해서 불이익이 없지만, 떨어져있기때문에 query할때 join을 하는 과정을 거쳐야해서 이 때 퍼포먼스가 떨어질 수 있다
- 답변(민정) 영문p247, parent/child의 장점: 문서가 분리되어 있고, update가 따로 업데이트 될 수 있다. join퍼포먼스가 app에서 처리하는 것보다 더 좋다 단점: 보통 쿼리가 nested보다 더 비싸다 메모리를 더 많이 먹는다. aggregation을 child 도큐먼트에만 할 수 있다(이건 무슨말인지 모르겠다)
- object는 auto-complete같이 1:1대응에 좋을 것 같다
- nested는 쓰기가 operation이 많이 없는 것에 쓰면 좋을 것 같다
- Parent/child는 쓰기 op가 많이 있는 모델 디자인에 쓰면 좋을 것 같다

### 성우
- 8.1 관계를 ES에서 어떻게 다루는지에 대해 객체 타입, 중첩 타입, 부모-자식 모델이 있음. 거기에 대해 다루는 방법은 Denormalizing, Application-side. Figure 8.1~8.5로 설명을 잘해놔서 이해가 잘됐음.
- 로케이션 서비스를 생각했을때 기본적으로 네스티드를 하고 데이터 디노멀라이즈를 했었음. 로케이션의 리전, 네이션, 시티가 있고 네이션/시티 룩업을 했었음. 이 책을 읽고나서 보니까 잘했다는 생각이 듬. 퍼포먼스 측면에서. 왜냐면 네스티드는 쓰기 작업이 퍼포먼스가 낮고 읽기 작업이 좋고 로케이션은 쓰기 작업이 없기 때문에. 디노멀라이즈도 쓰기 작업이 없기때문에 좋은 솔루션이라고 생각함.
- 어그리게이션 예제 데이터가 안 들어가서 왜 안들어가냐 봤더니 페런트-차일드 넣는 구조가 1.6 에서는 페런트-차일드 구조가 없어졌고 조인 데이터 타입이라는 걸 만듬. 타입은 하나 밖에 못가져서 타입에다가 쓸 스키마를 2개 집어넣음. https://www.elastic.co/guide/en/elasticsearch/reference/master/parent-join.html 그래서 페런트-차일드 예제 샘플을 고쳐서 이제 들어갈것임.
- 오브젝트 타입은 json 형태인데 그림 8.6을 보면 원본에는 계층 구조가 있는데 인덱싱되면 계층 구조가 생김. 1:M 관계에서는 인덱싱할때 여러개가 들어가게되면 관계형이 깨짐. 그래서 1:1 관계에서만 동작함. 예를 들어서 박성우라는 사람을 찾고 싶은데 박우현, 김성우가 있으면 두 사람이 나오는 이상한 결과가 나옴(데이터구조: Firstname- 박, lastname- 성우)
- 앱에서의 조인을 보는게 좋을거 같음. 로케이션에 적용할 수 있을거 같아서.

### 재면
- 도원님이 빨리 커피를 사오셨으면 좋겠습니다ㅎㅎ
